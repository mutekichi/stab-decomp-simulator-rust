# WIP
from __future__ import annotations

from typing import Optional, overload

class QuantumCircuit:
    """
    Represents a quantum circuit as a sequence of quantum gates.
    """

    # __init__ corresponds to #[new]
    def __init__(self, num_qubits: int) -> None: ...

    # #[staticmethod]
    @staticmethod
    def from_qasm_file(path: str) -> QuantumCircuit: ...

    @staticmethod
    def from_qasm_str(qasm: str) -> QuantumCircuit: ...

    @staticmethod
    def random_clifford(n: int, seed: Optional[int] = None) -> QuantumCircuit: ...

    # Instance methods
    def apply_gate(self, gate_name: str, qubits: list[int]) -> None: ...
    def apply_h(self, target: int) -> None: ...
    def apply_x(self, target: int) -> None: ...
    def apply_y(self, target: int) -> None: ...
    def apply_z(self, target: int) -> None: ...
    def apply_s(self, target: int) -> None: ...
    def apply_sdg(self, target: int) -> None: ...
    def apply_t(self, target: int) -> None: ...
    def apply_tdg(self, target: int) -> None: ...
    def apply_cx(self, control: int, target: int) -> None: ...
    def apply_cz(self, qarg1: int, qarg2: int) -> None: ...

    def __str__(self) -> str: ...

class QuantumState:
    """
    Represents a simulated quantum state.
    """

    # #[getter] properties
    @property
    def stabilizer_rank(self) -> int: ...

    @property
    def num_qubits(self) -> int: ...

    # Methods
    def exp_value(self, pauli_string: str) -> float: ...
    def sample(self, qargs: list[int], shots: int) -> dict[str, int]: ...
    def apply_h(self, target: int) -> None: ...

    def __str__(self) -> str: ...
